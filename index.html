<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hill Climb Racing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            overflow: hidden;
            touch-action: none;
        }
        #gameCanvas {
            display: block;
            max-width: 100%;
            max-height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Responsive canvas
        function resizeCanvas() {
            canvas.width = Math.min(1200, window.innerWidth);
            canvas.height = Math.min(700, window.innerHeight);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game constants
        const GRAVITY = 0.4;
        const GROUND_FRICTION = 0.985;
        const AIR_FRICTION = 0.999;
        const MAX_SPEED = 15;
        const ACCELERATION = 0.25;
        const BRAKE_POWER = 0.15;

        // Game state
        let gameRunning = true;
        let distance = 0;
        let coins = 0;
        let fuel = 100;
        let cameraX = 0;
        let targetCameraX = 0;
        let lastTime = 0;
        let deltaTime = 0;

        // Controls
        let gasPressed = false;
        let brakePressed = false;

        // Terrain using smooth curves
        class Terrain {
            constructor() {
                this.points = [];
                this.decorations = [];
                this.coins = [];
                this.segmentWidth = 30;
                this.generate(0, 3000);
            }

            generate(startX, endX) {
                for (let x = startX; x <= endX; x += this.segmentWidth) {
                    const y = this.getBaseHeight(x);
                    this.points.push({ x, y });

                    // Add trees
                    if (Math.random() < 0.03) {
                        this.decorations.push({
                            type: 'tree',
                            x: x,
                            y: y,
                            size: 0.7 + Math.random() * 0.6
                        });
                    }

                    // Add coins
                    if (Math.random() < 0.02 && x > 500) {
                        this.coins.push({
                            x: x,
                            y: y - 60 - Math.random() * 40,
                            collected: false,
                            bobOffset: Math.random() * Math.PI * 2
                        });
                    }
                }
            }

            getBaseHeight(x) {
                // Multiple sine waves for natural looking terrain
                let h = canvas.height * 0.6;
                h += Math.sin(x * 0.003) * 80;
                h += Math.sin(x * 0.007) * 50;
                h += Math.sin(x * 0.015) * 30;
                h += Math.sin(x * 0.001) * 120;
                
                // Add some bumps
                h += Math.sin(x * 0.05) * 8;
                
                return h;
            }

            getHeightAt(x) {
                // Smooth interpolation between points
                const index = Math.floor(x / this.segmentWidth);
                const t = (x % this.segmentWidth) / this.segmentWidth;
                
                const p0 = this.getPointAt(index - 1);
                const p1 = this.getPointAt(index);
                const p2 = this.getPointAt(index + 1);
                const p3 = this.getPointAt(index + 2);

                // Catmull-Rom spline interpolation for smoothness
                return this.catmullRom(p0.y, p1.y, p2.y, p3.y, t);
            }

            getPointAt(index) {
                if (index < 0) return { x: index * this.segmentWidth, y: this.getBaseHeight(index * this.segmentWidth) };
                if (index >= this.points.length) {
                    const x = index * this.segmentWidth;
                    return { x, y: this.getBaseHeight(x) };
                }
                return this.points[index];
            }

            catmullRom(p0, p1, p2, p3, t) {
                const t2 = t * t;
                const t3 = t2 * t;
                return 0.5 * (
                    (2 * p1) +
                    (-p0 + p2) * t +
                    (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
                    (-p0 + 3 * p1 - 3 * p2 + p3) * t3
                );
            }

            getAngleAt(x) {
                const delta = 2;
                const h1 = this.getHeightAt(x - delta);
                const h2 = this.getHeightAt(x + delta);
                return Math.atan2(h2 - h1, delta * 2);
            }

            extend() {
                const lastX = this.points[this.points.length - 1].x;
                if (lastX < cameraX + canvas.width + 500) {
                    this.generate(lastX + this.segmentWidth, lastX + 1000);
                }
            }

            draw() {
                const startX = Math.max(0, cameraX - 100);
                const endX = cameraX + canvas.width + 100;

                // Draw fill
                ctx.beginPath();
                ctx.moveTo(startX - cameraX, canvas.height);
                
                for (let x = startX; x <= endX; x += 5) {
                    const y = this.getHeightAt(x);
                    ctx.lineTo(x - cameraX, y);
                }
                
                ctx.lineTo(endX - cameraX, canvas.height);
                ctx.closePath();

                // Gradient fill
                const gradient = ctx.createLinearGradient(0, canvas.height * 0.4, 0, canvas.height);
                gradient.addColorStop(0, '#4a7c23');
                gradient.addColorStop(0.1, '#3d6b1e');
                gradient.addColorStop(0.4, '#8B4513');
                gradient.addColorStop(1, '#654321');
                ctx.fillStyle = gradient;
                ctx.fill();

                // Draw grass line on top
                ctx.beginPath();
                for (let x = startX; x <= endX; x += 3) {
                    const y = this.getHeightAt(x);
                    if (x === startX) ctx.moveTo(x - cameraX, y);
                    else ctx.lineTo(x - cameraX, y);
                }
                ctx.strokeStyle = '#2d5016';
                ctx.lineWidth = 4;
                ctx.stroke();

                // Draw grass blades
                ctx.strokeStyle = '#3d6b1e';
                ctx.lineWidth = 2;
                for (let x = startX; x <= endX; x += 15) {
                    const y = this.getHeightAt(x);
                    const angle = this.getAngleAt(x);
                    ctx.save();
                    ctx.translate(x - cameraX, y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-3, -10 - Math.random() * 5);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(3, -8 - Math.random() * 5);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            drawDecorations() {
                this.decorations.forEach(dec => {
                    const screenX = dec.x - cameraX;
                    if (screenX > -100 && screenX < canvas.width + 100) {
                        if (dec.type === 'tree') {
                            this.drawTree(screenX, dec.y, dec.size);
                        }
                    }
                });
            }

            drawTree(x, y, size) {
                ctx.save();
                ctx.translate(x, y);
                ctx.scale(size, size);

                // Trunk
                ctx.fillStyle = '#5D4037';
                ctx.fillRect(-8, -60, 16, 60);

                // Leaves layers
                const leafColors = ['#2E7D32', '#388E3C', '#43A047'];
                for (let i = 0; i < 3; i++) {
                    ctx.fillStyle = leafColors[i];
                    ctx.beginPath();
                    ctx.moveTo(0, -140 + i * 25);
                    ctx.lineTo(-35 + i * 5, -60 + i * 25);
                    ctx.lineTo(35 - i * 5, -60 + i * 25);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }

            drawCoins(time) {
                this.coins.forEach(coin => {
                    if (!coin.collected) {
                        const screenX = coin.x - cameraX;
                        if (screenX > -50 && screenX < canvas.width + 50) {
                            const bobY = coin.y + Math.sin(time * 0.003 + coin.bobOffset) * 5;
                            
                            // Glow
                            const glow = ctx.createRadialGradient(screenX, bobY, 0, screenX, bobY, 25);
                            glow.addColorStop(0, 'rgba(255, 215, 0, 0.4)');
                            glow.addColorStop(1, 'rgba(255, 215, 0, 0)');
                            ctx.fillStyle = glow;
                            ctx.beginPath();
                            ctx.arc(screenX, bobY, 25, 0, Math.PI * 2);
                            ctx.fill();

                            // Coin
                            ctx.beginPath();
                            ctx.arc(screenX, bobY, 14, 0, Math.PI * 2);
                            const coinGrad = ctx.createLinearGradient(screenX - 14, bobY - 14, screenX + 14, bobY + 14);
                            coinGrad.addColorStop(0, '#FFD700');
                            coinGrad.addColorStop(0.5, '#FFF8DC');
                            coinGrad.addColorStop(1, '#DAA520');
                            ctx.fillStyle = coinGrad;
                            ctx.fill();
                            ctx.strokeStyle = '#B8860B';
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            // $ symbol
                            ctx.fillStyle = '#B8860B';
                            ctx.font = 'bold 14px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('$', screenX, bobY + 1);
                        }
                    }
                });
            }
        }

        // Particle system for dust and effects
        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            emit(x, y, type) {
                const count = type === 'dust' ? 3 : 5;
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: -Math.random() * 3 - 1,
                        life: 1,
                        decay: 0.02 + Math.random() * 0.02,
                        size: 5 + Math.random() * 10,
                        type
                    });
                }
            }

            update() {
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1;
                    p.life -= p.decay;
                    return p.life > 0;
                });
            }

            draw() {
                this.particles.forEach(p => {
                    const screenX = p.x - cameraX;
                    ctx.globalAlpha = p.life * 0.6;
                    
                    if (p.type === 'dust') {
                        ctx.fillStyle = '#8B7355';
                    } else {
                        ctx.fillStyle = '#555';
                    }
                    
                    ctx.beginPath();
                    ctx.arc(screenX, p.y, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }
        }

        // Car class with improved physics
        class Car {
            constructor() {
                this.x = 200;
                this.y = 100;
                this.vx = 0;
                this.vy = 0;
                this.angle = 0;
                this.angularVel = 0;
                this.width = 90;
                this.height = 35;
                this.wheelBase = 60;
                this.wheelRadius = 18;
                this.wheelRotation = 0;
                this.onGround = false;
                this.frontWheelY = 0;
                this.rearWheelY = 0;
                this.suspensionFront = 0;
                this.suspensionRear = 0;
                this.targetSuspensionFront = 0;
                this.targetSuspensionRear = 0;
            }

            update(terrain) {
                // Wheel positions in world space
                const cos = Math.cos(this.angle);
                const sin = Math.sin(this.angle);
                const frontX = this.x + cos * this.wheelBase / 2;
                const rearX = this.x - cos * this.wheelBase / 2;

                // Get terrain heights at wheel positions
                const frontTerrainY = terrain.getHeightAt(frontX);
                const rearTerrainY = terrain.getHeightAt(rearX);

                // Calculate wheel Y positions
                const frontWheelWorldY = this.y + sin * this.wheelBase / 2;
                const rearWheelWorldY = this.y - sin * this.wheelBase / 2;

                // Check ground contact
                const frontContact = frontWheelWorldY + this.wheelRadius >= frontTerrainY;
                const rearContact = rearWheelWorldY + this.wheelRadius >= rearTerrainY;
                this.onGround = frontContact || rearContact;

                // Apply gravity
                this.vy += GRAVITY;

                // Suspension physics
                if (frontContact) {
                    const penetration = (frontWheelWorldY + this.wheelRadius) - frontTerrainY;
                    this.targetSuspensionFront = Math.min(penetration, 15);
                    this.vy -= penetration * 0.3;
                    this.angularVel += penetration * 0.002;
                } else {
                    this.targetSuspensionFront = 0;
                }

                if (rearContact) {
                    const penetration = (rearWheelWorldY + this.wheelRadius) - rearTerrainY;
                    this.targetSuspensionRear = Math.min(penetration, 15);
                    this.vy -= penetration * 0.3;
                    this.angularVel -= penetration * 0.002;
                } else {
                    this.targetSuspensionRear = 0;
                }

                // Smooth suspension
                this.suspensionFront += (this.targetSuspensionFront - this.suspensionFront) * 0.3;
                this.suspensionRear += (this.targetSuspensionRear - this.suspensionRear) * 0.3;

                // Calculate target angle from terrain
                if (this.onGround) {
                    const targetAngle = Math.atan2(frontTerrainY - rearTerrainY, this.wheelBase);
                    this.angularVel += (targetAngle - this.angle) * 0.08;
                }

                // Apply controls
                if (this.onGround) {
                    if (gasPressed && fuel > 0) {
                        const power = ACCELERATION * (1 - Math.abs(this.vx) / MAX_SPEED * 0.5);
                        this.vx += power * cos;
                        fuel -= 0.03;
                        // Wheel spin effect
                        this.wheelRotation += 0.3;
                    }
                    if (brakePressed) {
                        this.vx -= BRAKE_POWER * Math.sign(this.vx) * cos;
                        if (this.vx < 0) {
                            this.vx -= ACCELERATION * 0.5 * cos;
                        }
                    }
                    // Friction
                    this.vx *= GROUND_FRICTION;
                } else {
                    this.vx *= AIR_FRICTION;
                    // Air control
                    if (gasPressed) this.angularVel -= 0.003;
                    if (brakePressed) this.angularVel += 0.003;
                }

                // Slope effect
                if (this.onGround) {
                    this.vx += Math.sin(this.angle) * 0.15;
                }

                // Apply angular velocity
                this.angularVel *= 0.95;
                this.angle += this.angularVel;

                // Clamp angle for stability
                if (this.onGround) {
                    this.angle = Math.max(-0.7, Math.min(0.7, this.angle));
                }

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Wheel rotation based on speed
                this.wheelRotation += this.vx * 0.1;

                // Keep above terrain
                const centerTerrainY = terrain.getHeightAt(this.x);
                if (this.y + this.height / 2 > centerTerrainY) {
                    this.y = centerTerrainY - this.height / 2;
                    this.vy = 0;
                }

                // Check flip
                if (Math.abs(this.angle) > Math.PI * 0.6) {
                    return true; // Game over
                }

                return false;
            }

            draw() {
                const screenX = this.x - cameraX;
                
                ctx.save();
                ctx.translate(screenX, this.y);
                ctx.rotate(this.angle);

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(5, this.height / 2 + 10, this.width / 2, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw wheels first (behind body)
                this.drawWheel(-this.wheelBase / 2, this.height / 2 - this.suspensionRear);
                this.drawWheel(this.wheelBase / 2, this.height / 2 - this.suspensionFront);

                // Car body - main chassis
                const bodyGrad = ctx.createLinearGradient(0, -this.height, 0, this.height / 2);
                bodyGrad.addColorStop(0, '#FF5252');
                bodyGrad.addColorStop(0.5, '#D32F2F');
                bodyGrad.addColorStop(1, '#B71C1C');
                ctx.fillStyle = bodyGrad;

                // Main body shape
                ctx.beginPath();
                ctx.moveTo(-this.width / 2 + 5, this.height / 2 - 5);
                ctx.lineTo(-this.width / 2, 0);
                ctx.lineTo(-this.width / 2 + 10, -this.height / 2);
                ctx.lineTo(this.width / 2 - 5, -this.height / 2);
                ctx.lineTo(this.width / 2, 0);
                ctx.lineTo(this.width / 2 - 5, this.height / 2 - 5);
                ctx.closePath();
                ctx.fill();

                // Body outline
                ctx.strokeStyle = '#8B0000';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Cabin / windshield
                const cabinGrad = ctx.createLinearGradient(0, -this.height, 0, 0);
                cabinGrad.addColorStop(0, '#81D4FA');
                cabinGrad.addColorStop(1, '#29B6F6');
                ctx.fillStyle = cabinGrad;

                ctx.beginPath();
                ctx.moveTo(-10, -this.height / 2);
                ctx.lineTo(-15, -this.height / 2 - 20);
                ctx.lineTo(20, -this.height / 2 - 20);
                ctx.lineTo(25, -this.height / 2);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#0277BD';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Cabin top
                ctx.fillStyle = '#C62828';
                ctx.beginPath();
                ctx.moveTo(-15, -this.height / 2 - 20);
                ctx.lineTo(-12, -this.height / 2 - 28);
                ctx.lineTo(18, -this.height / 2 - 28);
                ctx.lineTo(20, -this.height / 2 - 20);
                ctx.closePath();
                ctx.fill();

                // Headlight
                ctx.fillStyle = '#FFEB3B';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 - 8, -5, 6, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#FBC02D';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Taillight
                ctx.fillStyle = '#F44336';
                ctx.beginPath();
                ctx.ellipse(-this.width / 2 + 8, -5, 4, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Exhaust pipe
                ctx.fillStyle = '#424242';
                ctx.fillRect(-this.width / 2 - 5, this.height / 2 - 12, 8, 6);

                ctx.restore();
            }

            drawWheel(offsetX, offsetY) {
                ctx.save();
                ctx.translate(offsetX, offsetY);
                ctx.rotate(this.wheelRotation);

                // Tire
                const tireGrad = ctx.createRadialGradient(0, 0, this.wheelRadius * 0.5, 0, 0, this.wheelRadius);
                tireGrad.addColorStop(0, '#424242');
                tireGrad.addColorStop(0.7, '#212121');
                tireGrad.addColorStop(1, '#000');
                ctx.fillStyle = tireGrad;
                ctx.beginPath();
                ctx.arc(0, 0, this.wheelRadius, 0, Math.PI * 2);
                ctx.fill();

                // Tire treads
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * this.wheelRadius * 0.6, Math.sin(angle) * this.wheelRadius * 0.6);
                    ctx.lineTo(Math.cos(angle) * this.wheelRadius * 0.95, Math.sin(angle) * this.wheelRadius * 0.95);
                    ctx.stroke();
                }

                // Rim
                const rimGrad = ctx.createRadialGradient(-2, -2, 0, 0, 0, this.wheelRadius * 0.5);
                rimGrad.addColorStop(0, '#E0E0E0');
                rimGrad.addColorStop(0.5, '#9E9E9E');
                rimGrad.addColorStop(1, '#616161');
                ctx.fillStyle = rimGrad;
                ctx.beginPath();
                ctx.arc(0, 0, this.wheelRadius * 0.45, 0, Math.PI * 2);
                ctx.fill();

                // Hub
                ctx.fillStyle = '#757575';
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();

                // Spokes
                ctx.strokeStyle = '#BDBDBD';
                ctx.lineWidth = 3;
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * this.wheelRadius * 0.4, Math.sin(angle) * this.wheelRadius * 0.4);
                    ctx.stroke();
                }

                ctx.restore();
            }

            getWorldPosition() {
                return { x: this.x, y: this.y };
            }
        }

        // Background with parallax
        class Background {
            constructor() {
                this.mountains = [];
                this.clouds = [];
                
                for (let i = 0; i < 8; i++) {
                    this.mountains.push({
                        x: i * 300,
                        height: 100 + Math.random() * 150,
                        width: 200 + Math.random() * 200
                    });
                }

                for (let i = 0; i < 10; i++) {
                    this.clouds.push({
                        x: Math.random() * 2000,
                        y: 30 + Math.random() * 100,
                        size: 0.5 + Math.random() * 1
                    });
                }
            }

            draw() {
                // Sky gradient
                const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.7);
                skyGrad.addColorStop(0, '#1565C0');
                skyGrad.addColorStop(0.5, '#42A5F5');
                skyGrad.addColorStop(1, '#90CAF9');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Sun
                const sunX = canvas.width * 0.8;
                const sunY = 80;
                const sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 60);
                sunGrad.addColorStop(0, '#FFF59D');
                sunGrad.addColorStop(0.3, '#FFEB3B');
                sunGrad.addColorStop(1, 'rgba(255, 235, 59, 0)');
                ctx.fillStyle = sunGrad;
                ctx.beginPath();
                ctx.arc(sunX, sunY, 60, 0, Math.PI * 2);
                ctx.fill();

                // Clouds with slow parallax
                this.clouds.forEach(cloud => {
                    const screenX = ((cloud.x - cameraX * 0.05) % (canvas.width + 200)) - 100;
                    this.drawCloud(screenX, cloud.y, cloud.size);
                });

                // Far mountains with parallax
                this.mountains.forEach((m, i) => {
                    const screenX = ((m.x - cameraX * 0.1) % (canvas.width + 400)) - 200;
                    const colors = i % 2 === 0 ? ['#5D4037', '#4E342E'] : ['#6D4C41', '#5D4037'];
                    this.drawMountain(screenX, canvas.height * 0.65, m.width, m.height, colors);
                });

                // Near hills with more parallax
                for (let i = 0; i < 5; i++) {
                    const screenX = ((i * 400 - cameraX * 0.2) % (canvas.width + 500)) - 250;
                    this.drawMountain(screenX, canvas.height * 0.7, 350, 80 + i * 20, ['#66BB6A', '#4CAF50']);
                }
            }

            drawCloud(x, y, size) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, 25 * size, 0, Math.PI * 2);
                ctx.arc(x + 30 * size, y - 10 * size, 35 * size, 0, Math.PI * 2);
                ctx.arc(x + 60 * size, y, 25 * size, 0, Math.PI * 2);
                ctx.arc(x + 30 * size, y + 10 * size, 20 * size, 0, Math.PI * 2);
                ctx.fill();
            }

            drawMountain(x, baseY, width, height, colors) {
                const grad = ctx.createLinearGradient(x, baseY - height, x, baseY);
                grad.addColorStop(0, colors[0]);
                grad.addColorStop(1, colors[1]);
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(x - width / 2, baseY);
                ctx.lineTo(x, baseY - height);
                ctx.lineTo(x + width / 2, baseY);
                ctx.closePath();
                ctx.fill();
            }
        }

        // UI class
        class UI {
            draw(time) {
                // Fuel gauge
                this.drawFuelGauge();
                
                // Speedometer
                this.drawSpeedometer();

                // Distance and coins
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                this.roundRect(15, 15, 180, 70, 10);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`${distance}m`, 25, 42);
                
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 20px Arial';
                ctx.fillText(`ðŸ’° ${coins}`, 25, 70);

                // Mobile controls hint
                if ('ontouchstart' in window) {
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('â† BRAKE | GAS â†’', canvas.width / 2, canvas.height - 20);
                }
            }

            drawFuelGauge() {
                const x = canvas.width - 180;
                const y = 20;
                const width = 160;
                const height = 25;

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                this.roundRect(x - 10, y - 10, width + 20, height + 35, 10);
                ctx.fill();

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('FUEL', x + width / 2, y + height + 18);

                // Empty bar
                ctx.fillStyle = '#333';
                this.roundRect(x, y, width, height, 5);
                ctx.fill();

                // Fuel level
                const fuelWidth = (fuel / 100) * width;
                const fuelColor = fuel > 30 ? '#4CAF50' : fuel > 15 ? '#FF9800' : '#F44336';
                
                const fuelGrad = ctx.createLinearGradient(x, y, x, y + height);
                fuelGrad.addColorStop(0, fuelColor);
                fuelGrad.addColorStop(1, this.darkenColor(fuelColor));
                ctx.fillStyle = fuelGrad;
                
                if (fuelWidth > 0) {
                    this.roundRect(x, y, fuelWidth, height, 5);
                    ctx.fill();
                }

                // Shine
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                this.roundRect(x + 2, y + 2, fuelWidth - 4, height / 3, 3);
                ctx.fill();

                // Border
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 2;
                this.roundRect(x, y, width, height, 5);
                ctx.stroke();
            }

            drawSpeedometer() {
                const x = canvas.width - 90;
                const y = 120;
                const radius = 50;

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(x, y, radius + 10, 0, Math.PI * 2);
                ctx.fill();

                // Dial background
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Speed arc
                const speed = Math.abs(car.vx);
                const speedRatio = Math.min(speed / MAX_SPEED, 1);
                const startAngle = Math.PI * 0.8;
                const endAngle = Math.PI * 0.8 + speedRatio * Math.PI * 1.4;

                ctx.strokeStyle = speedRatio > 0.8 ? '#F44336' : '#4CAF50';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.arc(x, y, radius - 10, startAngle, endAngle);
                ctx.stroke();

                // Speed text
                const displaySpeed = Math.floor(speed * 10);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(displaySpeed, x, y + 5);
                ctx.font = '10px Arial';
                ctx.fillText('km/h', x, y + 18);
            }

            roundRect(x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
            }

            darkenColor(color) {
                const num = parseInt(color.slice(1), 16);
                const r = Math.max((num >> 16) - 40, 0);
                const g = Math.max(((num >> 8) & 0x00FF) - 40, 0);
                const b = Math.max((num & 0x0000FF) - 40, 0);
                return `rgb(${r},${g},${b})`;
            }

            drawGameOver() {
                // Overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Panel
                const panelWidth = 320;
                const panelHeight = 220;
                const px = (canvas.width - panelWidth) / 2;
                const py = (canvas.height - panelHeight) / 2;

                ctx.fillStyle = 'rgba(30, 30, 30, 0.95)';
                this.roundRect(px, py, panelWidth, panelHeight, 15);
                ctx.fill();
                ctx.strokeStyle = '#F44336';
                ctx.lineWidth = 3;
                this.roundRect(px, py, panelWidth, panelHeight, 15);
                ctx.stroke();

                // Text
                ctx.fillStyle = '#F44336';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, py + 50);

                ctx.fillStyle = '#fff';
                ctx.font = '22px Arial';
                ctx.fillText(`Distance: ${distance}m`, canvas.width / 2, py + 100);
                ctx.fillText(`Coins: ${coins}`, canvas.width / 2, py + 135);

                // Restart button
                ctx.fillStyle = '#4CAF50';
                this.roundRect(canvas.width / 2 - 80, py + 155, 160, 45, 8);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('TAP TO RESTART', canvas.width / 2, py + 183);
            }
        }

        // Initialize game objects
        let terrain = new Terrain();
        let car = new Car();
        let background = new Background();
        let particles = new ParticleSystem();
        let ui = new UI();

        // Main game loop
        function gameLoop(timestamp) {
            deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameRunning) {
                // Update
                const gameOver = car.update(terrain);
                
                if (gameOver || (fuel <= 0 && Math.abs(car.vx) < 0.5)) {
                    gameRunning = false;
                }

                // Update camera with smooth follow
                targetCameraX = car.x - canvas.width * 0.3;
                cameraX += (targetCameraX - cameraX) * 0.08;
                cameraX = Math.max(0, cameraX);

                // Update distance
                distance = Math.max(distance, Math.floor(car.x / 10));

                // Extend terrain
                terrain.extend();

                // Collect coins
                terrain.coins.forEach(coin => {
                    if (!coin.collected) {
                        const dx = coin.x - car.x;
                        const dy = coin.y - car.y;
                        if (Math.sqrt(dx * dx + dy * dy) < 50) {
                            coin.collected = true;
                            coins += 10;
                            fuel = Math.min(100, fuel + 8);
                        }
                    }
                });

                // Emit particles when moving on ground
                if (car.onGround && Math.abs(car.vx) > 2) {
                    if (Math.random() < 0.3) {
                        const wheelX = car.x - Math.cos(car.angle) * car.wheelBase / 2;
                        const wheelY = terrain.getHeightAt(wheelX);
                        particles.emit(wheelX, wheelY, 'dust');
                    }
                }

                particles.update();
            }

            // Draw everything
            background.draw();
            terrain.drawDecorations();
            terrain.draw();
            terrain.drawCoins(timestamp);
            particles.draw();
            car.draw();
            ui.draw(timestamp);

            if (!gameRunning) {
                ui.drawGameOver();
            }

            requestAnimationFrame(gameLoop);
        }

        // Restart function
        function restart() {
            terrain = new Terrain();
            car = new Car();
            particles = new ParticleSystem();
            distance = 0;
            coins = 0;
            fuel = 100;
            cameraX = 0;
            targetCameraX = 0;
            gameRunning = true;
        }

        // Controls
        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') gasPressed = true;
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') brakePressed = true;
            if (!gameRunning && (e.key === ' ' || e.key === 'Enter')) restart();
        });

        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') gasPressed = false;
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') brakePressed = false;
        });

        // Touch controls
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            if (!gameRunning) {
                restart();
                return;
            }
            Array.from(e.touches).forEach(touch => {
                if (touch.clientX < canvas.width / 2) brakePressed = true;
                else gasPressed = true;
            });
        });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            const activeTouches = Array.from(e.touches);
            const leftTouch = activeTouches.find(t => t.clientX < canvas.width / 2);
            const rightTouch = activeTouches.find(t => t.clientX >= canvas.width / 2);
            if (!leftTouch) brakePressed = false;
            if (!rightTouch) gasPressed = false;
        });

        canvas.addEventListener('touchcancel', () => {
            gasPressed = false;
            brakePressed = false;
        });

        // Mouse controls for testing
        canvas.addEventListener('mousedown', e => {
            if (!gameRunning) {
                restart();
                return;
            }
            if (e.clientX < canvas.width / 2) brakePressed = true;
            else gasPressed = true;
        });

        canvas.addEventListener('mouseup', () => {
            gasPressed = false;
            brakePressed = false;
        });

        canvas.addEventListener('mouseleave', () => {
            gasPressed = false;
            brakePressed = false;
        });

        // Start game
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
